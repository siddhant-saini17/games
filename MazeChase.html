<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Chase Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .stats-container {
            display: flex;
            justify-content: space-between;
            width: 800px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }
        
        canvas {
            border: 4px solid #2121DE;
            box-shadow: 0 0 20px rgba(33,33,222,0.5);
        }
        
        .instructions {
            text-align: center;
            font-size: 16px;
            margin-top: 10px;
        }
        
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            border: 5px solid white;
            z-index: 100;
        }
        
        .modal h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .modal p {
            font-size: 32px;
            margin-bottom: 30px;
        }
        
        .modal button {
            padding: 20px 50px;
            font-size: 24px;
            background-color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .won-modal {
            background-color: rgba(0,200,0,0.95);
        }
        
        .won-modal button {
            color: green;
        }
        
        .lost-modal {
            background-color: rgba(200,0,0,0.95);
        }
        
        .lost-modal button {
            color: red;
        }
        
        .next-level-modal {
            background-color: rgba(0,0,200,0.95);
        }
        
        .next-level-modal button {
            color: blue;
        }
        
        .power-up-indicator {
            color: #FF1493;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="stats-container">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div id="level">Level: 1 / 10</div>
            <div id="power-up" class="power-up-indicator" style="display: none;">‚ö° POWER UP! ‚ö°</div>
        </div>
        
        <canvas id="game-canvas" width="800" height="560"></canvas>
        
        <div class="instructions">
            <div>Arrow Keys or WASD to move</div>
            <div>Ghosts plant bombs ‚Äî avoid the 3√ó3 blast area!</div>
        </div>
    </div>

    <div id="won-modal" class="modal won-modal" style="display: none;">
        <h1>üéâ YOU WIN! üéâ</h1>
        <p id="final-score">Final Score: 0</p>
        <button id="play-again-won">Play Again</button>
    </div>

    <div id="lost-modal" class="modal lost-modal" style="display: none;">
        <h1>üëª GAME OVER! üëª</h1>
        <p id="final-score-lost">Final Score: 0</p>
        <button id="play-again-lost">Try Again</button>
    </div>

    <div id="next-level-modal" class="modal next-level-modal" style="display: none;">
        <h1>üéä LEVEL COMPLETE! üéä</h1>
        <p id="level-score">Score: 0</p>
        <button id="next-level-button">Next Level ‚Üí</button>
    </div>

    <script>
        // Game constants
        const CELL_SIZE = 40;
        const COLS = 20;
        const ROWS = 14;
        const PACMAN_RADIUS = 15;
        const GHOST_RADIUS = 15;
        const DOT_RADIUS = 4;
        const POWERUP_RADIUS = 8;
        const BOMB_RADIUS = 10;
        const TURN_TOLERANCE = 6;

        // Base mazes
        const baseMazes = [
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1],
                [1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,1],
                [1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1],
                [1,1,1,1,0,0,0,0,1,3,3,1,0,0,0,0,1,1,1,1],
                [1,0,0,0,0,1,1,0,1,3,3,1,0,1,1,0,0,0,0,1],
                [1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1],
                [1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,1],
                [1,2,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,2,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1],
                [1,2,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,2,1],
                [1,0,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,1,1,0,1,1,0,1,1,3,3,1,1,0,1,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1],
                [1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
        ];

        // Game state
        let score = 0;
        let lives = 3;
        let currentLevel = 1;
        let gameStatus = "playing"; // playing, nextLevel, won, lost
        let powerUpActive = false;
        let powerUpTimer = 0;

        // Game objects
        let maze = [];
        let dots = [];
        let powerUps = [];
        let pacman = {
            x: 1.5 * CELL_SIZE,
            y: 1.5 * CELL_SIZE,
            direction: { x: 0, y: 0 },
            nextDirection: { x: 0, y: 0 },
            speed: 2.5,
            mouthOpen: 0,
        };
        
        const ghostStarts = [
            { r: 6, c: 9 },
            { r: 6, c: 10 },
            { r: 7, c: 9 },
            { r: 7, c: 10 },
            { r: 5, c: 9 },
            { r: 5, c: 10 },
            { r: 8, c: 9 },
            { r: 8, c: 10 },
        ];

        const ghostColors = ["#FF0000", "#00FFFF", "#FFA500", "#FFB6C1", "#8A2BE2", "#00FF00", "#FFD700", "#00CED1"];
        
        let ghosts = [];
        let bombs = [];
        let explosions = [];
        let frameCount = 0;
        let keys = {};

        // Utility functions
        const cellCenter = (row, col) => ({
            x: col * CELL_SIZE + CELL_SIZE / 2,
            y: row * CELL_SIZE + CELL_SIZE / 2,
        });

        const generateLevelMaze = (levelIndex) => {
            const base = JSON.parse(JSON.stringify(baseMazes[levelIndex % baseMazes.length]));
            for (let r = 1; r < ROWS - 1; r++) {
                for (let c = 1; c < COLS - 1; c++) {
                    const seed = (r * 31 + c * 17 + levelIndex * 13) % 100;
                    if (seed < Math.min(8, levelIndex)) {
                        if (base[r][c] === 0) base[r][c] = 1;
                        else if (base[r][c] === 1) base[r][c] = 0;
                    }
                    if (base[r][c] === 2 && levelIndex > 6) {
                        if ((r + c + levelIndex) % 3 === 0) base[r][c] = 0;
                    }
                }
            }
            return base;
        };

        const initCollectibles = (maze) => {
            const dots = [];
            const powerUps = [];
            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[0].length; c++) {
                    if (maze[r][c] === 0) {
                        dots.push({ r, c, ...cellCenter(r, c), collected: false });
                    } else if (maze[r][c] === 2) {
                        powerUps.push({ r, c, ...cellCenter(r, c), collected: false });
                    }
                }
            }
            return { dots, powerUps };
        };

        const getCell = (x, y) => {
            const c = Math.floor(x / CELL_SIZE);
            const r = Math.floor(y / CELL_SIZE);
            return { r, c };
        };

        const inBounds = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;

        const isWall = (x, y) => {
            const { r, c } = getCell(x, y);
            if (!inBounds(r, c)) return true;
            return maze[r][c] === 1;
        };

        const canMoveTo = (x, y, radius = PACMAN_RADIUS) => {
            const checkPts = [
                { x: x - radius + 1, y: y - radius + 1 },
                { x: x + radius - 1, y: y - radius + 1 },
                { x: x - radius + 1, y: y + radius - 1 },
                { x: x + radius - 1, y: y + radius - 1 },
                { x, y },
            ];
            return checkPts.every(p => !isWall(p.x, p.y));
        };

        const tryChangeDirection = () => {
            if (pacman.nextDirection.x === 0 && pacman.nextDirection.y === 0) return;
            const curCell = getCell(pacman.x, pacman.y);
            const center = cellCenter(curCell.r, curCell.c);

            const newX = pacman.x + pacman.nextDirection.x * pacman.speed;
            const newY = pacman.y + pacman.nextDirection.y * pacman.speed;
            if (canMoveTo(newX, newY, PACMAN_RADIUS - 2)) {
                const dx = Math.abs(pacman.x - center.x);
                const dy = Math.abs(pacman.y - center.y);
                if ((pacman.nextDirection.x !== 0 && dy < TURN_TOLERANCE) ||
                    (pacman.nextDirection.y !== 0 && dx < TURN_TOLERANCE)) {
                    if (pacman.nextDirection.x !== 0) pacman.y = center.y;
                    if (pacman.nextDirection.y !== 0) pacman.x = center.x;
                    pacman.direction = { ...pacman.nextDirection };
                } else {
                    pacman.direction = { ...pacman.nextDirection };
                }
            }
        };

        const findNearestWalkableCell = (x, y) => {
            const start = getCell(x, y);
            if (inBounds(start.r, start.c) && maze[start.r][start.c] !== 1) return start;
            const radius = 2;
            for (let d = 1; d <= radius; d++) {
                for (let dr = -d; dr <= d; dr++) {
                    for (let dc = -d; dc <= d; dc++) {
                        const r = start.r + dr;
                        const c = start.c + dc;
                        if (inBounds(r, c) && maze[r][c] !== 1) return { r, c };
                    }
                }
            }
            return null;
        };

        const plantBombAt = (r, c, ownerId) => {
            if (bombs.some(b => b.r === r && b.c === c)) return;
            const pos = cellCenter(r, c);
            bombs.push({
                r, c,
                x: pos.x, y: pos.y,
                fuse: 180,
                ownerId,
                exploded: false,
            });
        };

        const explodeBomb = (bomb) => {
            const blastCells = [];
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const rr = bomb.r + dr;
                    const cc = bomb.c + dc;
                    if (inBounds(rr, cc)) blastCells.push({ r: rr, c: cc, x: cc * CELL_SIZE + CELL_SIZE / 2, y: rr * CELL_SIZE + CELL_SIZE / 2 });
                }
            }
            explosions.push({ cells: blastCells, timer: 30 });
            
            const pacCell = getCell(pacman.x, pacman.y);
            if (blastCells.some(bc => bc.r === pacCell.r && bc.c === pacCell.c)) {
                lives = Math.max(0, lives - 1);
                updateUI();
                if (lives <= 0) {
                    gameStatus = "lost";
                    showModal('lost');
                } else {
                    pacman.x = 1.5 * CELL_SIZE;
                    pacman.y = 1.5 * CELL_SIZE;
                    pacman.direction = { x: 0, y: 0 };
                    ghosts.forEach(g => { g.x = g.startX; g.y = g.startY; });
                }
            }
        };

        // UI functions
        const updateUI = () => {
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('lives').textContent = `Lives: ${'‚ù§Ô∏è'.repeat(Math.max(0, lives))}`;
            document.getElementById('level').textContent = `Level: ${currentLevel} / 10`;
            
            const powerUpElement = document.getElementById('power-up');
            if (powerUpActive) {
                powerUpElement.style.display = 'block';
            } else {
                powerUpElement.style.display = 'none';
            }
        };

        const showModal = (type) => {
            // Hide all modals first
            document.getElementById('won-modal').style.display = 'none';
            document.getElementById('lost-modal').style.display = 'none';
            document.getElementById('next-level-modal').style.display = 'none';
            
            if (type === 'won') {
                document.getElementById('final-score').textContent = `Final Score: ${score}`;
                document.getElementById('won-modal').style.display = 'block';
            } else if (type === 'lost') {
                document.getElementById('final-score-lost').textContent = `Final Score: ${score}`;
                document.getElementById('lost-modal').style.display = 'block';
            } else if (type === 'nextLevel') {
                document.getElementById('level-score').textContent = `Score: ${score}`;
                document.getElementById('next-level-modal').style.display = 'block';
            }
        };

        const hideAllModals = () => {
            document.getElementById('won-modal').style.display = 'none';
            document.getElementById('lost-modal').style.display = 'none';
            document.getElementById('next-level-modal').style.display = 'none';
        };

        // Drawing functions
        const drawFrame = () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze walls
            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[0].length; c++) {
                    if (maze[r][c] === 1) {
                        ctx.fillStyle = "#2121DE";
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = "#4040FF";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw dots
            dots.forEach(dot => {
                if (!dot.collected) {
                    ctx.fillStyle = "#FFB897";
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw powerups
            powerUps.forEach(pu => {
                if (!pu.collected) {
                    ctx.fillStyle = "#FF1493";
                    ctx.beginPath();
                    ctx.arc(pu.x, pu.y, POWERUP_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = "#FF69B4";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Draw bombs
            bombs.forEach(b => {
                ctx.fillStyle = "#333333";
                ctx.beginPath();
                ctx.arc(b.x, b.y, BOMB_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                const fuseProgress = Math.max(0, Math.min(1, b.fuse / 180));
                ctx.fillStyle = "#FF4500";
                ctx.beginPath();
                ctx.arc(b.x, b.y, BOMB_RADIUS * (1 - fuseProgress) + 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw explosions
            explosions.forEach(ex => {
                ex.cells.forEach(cell => {
                    ctx.fillStyle = "rgba(255, 80, 0, 0.85)";
                    ctx.fillRect(cell.x - CELL_SIZE / 2, cell.y - CELL_SIZE / 2, CELL_SIZE, CELL_SIZE);
                });
            });

            // Draw Pac-Man
            ctx.fillStyle = "#FFFF00";
            ctx.beginPath();
            const angle = Math.atan2(pacman.direction.y || 0.0001, pacman.direction.x || 0.0001);
            const mouthAngle = Math.abs(Math.sin(pacman.mouthOpen)) * 0.5;
            ctx.arc(pacman.x, pacman.y, PACMAN_RADIUS, angle + mouthAngle, angle + Math.PI * 2 - mouthAngle);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.fill();

            // Draw ghosts
            ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.scared ? "#0000FF" : ghost.color;
                ctx.beginPath();
                ctx.arc(ghost.x, ghost.y, GHOST_RADIUS, Math.PI, 0);
                ctx.lineTo(ghost.x + GHOST_RADIUS, ghost.y + GHOST_RADIUS);
                ctx.lineTo(ghost.x - GHOST_RADIUS, ghost.y + GHOST_RADIUS);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = "#FFFFFF";
                ctx.beginPath();
                ctx.arc(ghost.x - 5, ghost.y - 3, 4, 0, Math.PI * 2);
                ctx.arc(ghost.x + 5, ghost.y - 3, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#000000";
                ctx.beginPath();
                ctx.arc(ghost.x - 5, ghost.y - 3, 2, 0, Math.PI * 2);
                ctx.arc(ghost.x + 5, ghost.y - 3, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        };

        // Game loop
        const gameLoop = () => {
            if (gameStatus !== "playing") {
                drawFrame();
                return;
            }
            frameCount++;

            // Movement logic
            tryChangeDirection();

            // Move Pac-Man
            const nextPacX = pacman.x + pacman.direction.x * pacman.speed;
            const nextPacY = pacman.y + pacman.direction.y * pacman.speed;
            if (canMoveTo(nextPacX, nextPacY, PACMAN_RADIUS - 2)) {
                pacman.x = nextPacX;
                pacman.y = nextPacY;
            } else {
                pacman.direction = { x: 0, y: 0 };
            }

            // Pac-Man mouth animation
            pacman.mouthOpen += 0.15;

            // Collect dots
            dots.forEach(dot => {
                if (!dot.collected) {
                    const dx = pacman.x - dot.x;
                    const dy = pacman.y - dot.y;
                    if (dx * dx + dy * dy < (PACMAN_RADIUS + DOT_RADIUS) ** 2) {
                        dot.collected = true;
                        score += 10;
                        updateUI();
                    }
                }
            });

            // Collect power-ups
            powerUps.forEach(pu => {
                if (!pu.collected) {
                    const dx = pacman.x - pu.x;
                    const dy = pacman.y - pu.y;
                    if (dx * dx + dy * dy < (PACMAN_RADIUS + POWERUP_RADIUS) ** 2) {
                        pu.collected = true;
                        powerUpActive = true;
                        powerUpTimer = 600;
                        ghosts.forEach(g => g.scared = true);
                        score += 50;
                        updateUI();
                    }
                }
            });

            // Power-up timer
            if (powerUpTimer > 0) {
                powerUpTimer--;
                if (powerUpTimer === 0) {
                    powerUpActive = false;
                    ghosts.forEach(g => g.scared = false);
                    updateUI();
                }
            }

            // Ghosts AI
            ghosts.forEach(ghost => {
                const levelFactor = 1 + (currentLevel - 1) * 0.06;
                const ghostSpeed = ghost.scared ? -ghost.speed * 0.8 : ghost.speed * levelFactor;

                const toX = pacman.x - ghost.x;
                const toY = pacman.y - ghost.y;
                const dist = Math.sqrt(toX * toX + toY * toY) || 1;
                const dirX = toX / dist;
                const dirY = toY / dist;

                const candidateX = ghost.x + dirX * ghostSpeed;
                const candidateY = ghost.y + dirY * ghostSpeed;

                if (canMoveTo(candidateX, ghost.y, GHOST_RADIUS - 2)) ghost.x = candidateX;
                else if (canMoveTo(ghost.x, ghost.y + Math.sign(dirY) * Math.abs(ghostSpeed), GHOST_RADIUS - 2)) ghost.y += Math.sign(dirY) * Math.abs(ghostSpeed);
                else if (canMoveTo(ghost.x + Math.sign(dirX) * Math.abs(ghostSpeed), ghost.y, GHOST_RADIUS - 2)) ghost.x += Math.sign(dirX) * Math.abs(ghostSpeed);
                else {
                    const wiggleX = (Math.random() - 0.5) * 2;
                    const wiggleY = (Math.random() - 0.5) * 2;
                    if (canMoveTo(ghost.x + wiggleX, ghost.y + wiggleY, GHOST_RADIUS - 2)) {
                        ghost.x += wiggleX;
                        ghost.y += wiggleY;
                    }
                }

                // Bomb planting
                ghost.plantTimer -= Math.max(1, Math.floor(1 + (currentLevel - 1) * 0.12));
                if (ghost.plantTimer <= 0) {
                    const cell = findNearestWalkableCell(ghost.x, ghost.y);
                    if (cell && Math.random() < 0.8) {
                        plantBombAt(cell.r, cell.c, ghost.id);
                    }
                    ghost.plantCooldown = Math.max(80, Math.floor(200 - currentLevel * 10 + Math.random() * 80));
                    ghost.plantTimer = ghost.plantCooldown;
                }
            });

            // Bomb handling
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].fuse--;
                if (bombs[i].fuse <= 0 && !bombs[i].exploded) {
                    bombs[i].exploded = true;
                    explodeBomb(bombs[i]);
                    bombs.splice(i, 1);
                }
            }

            // Explosion handling
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].timer--;
                if (explosions[i].timer <= 0) explosions.splice(i, 1);
            }

            // Ghost-Pacman collision
            ghosts.forEach(ghost => {
                const dx = pacman.x - ghost.x;
                const dy = pacman.y - ghost.y;
                if (dx * dx + dy * dy < (PACMAN_RADIUS + GHOST_RADIUS) ** 2) {
                    if (ghost.scared) {
                        ghost.x = ghost.startX;
                        ghost.y = ghost.startY;
                        score += 200;
                        updateUI();
                        ghost.scared = false;
                    } else {
                        lives = Math.max(0, lives - 1);
                        updateUI();
                        if (lives <= 0) {
                            gameStatus = "lost";
                            showModal('lost');
                        } else {
                            pacman.x = 1.5 * CELL_SIZE;
                            pacman.y = 1.5 * CELL_SIZE;
                            pacman.direction = { x: 0, y: 0 };
                            ghosts.forEach(g => { g.x = g.startX; g.y = g.startY; });
                        }
                    }
                }
            });

            // Check win condition
            const allDots = dots.every(d => d.collected);
            const allPUs = powerUps.every(p => p.collected);
            if (allDots && allPUs) {
                if (currentLevel < 10) {
                    gameStatus = "nextLevel";
                    showModal('nextLevel');
                } else {
                    gameStatus = "won";
                    showModal('won');
                }
            }

            drawFrame();
            requestAnimationFrame(gameLoop);
        };

        // Initialize game
        const initGame = () => {
            // Hide all modals first
            hideAllModals();
            
            // Reset game state
            score = 0;
            lives = 3;
            currentLevel = 1;
            gameStatus = "playing";
            powerUpActive = false;
            powerUpTimer = 0;
            
            // Generate maze
            maze = generateLevelMaze(currentLevel);
            
            // Initialize collectibles
            const collectibles = initCollectibles(maze);
            dots = collectibles.dots;
            powerUps = collectibles.powerUps;
            
            // Reset Pac-Man
            pacman = {
                x: 1.5 * CELL_SIZE,
                y: 1.5 * CELL_SIZE,
                direction: { x: 0, y: 0 },
                nextDirection: { x: 0, y: 0 },
                speed: 2.5,
                mouthOpen: 0,
            };
            
            // Reset ghosts
            ghosts = ghostStarts.map((s, i) => {
                const center = cellCenter(s.r, s.c);
                return {
                    id: i,
                    x: center.x,
                    y: center.y,
                    color: ghostColors[i % ghostColors.length],
                    scared: false,
                    startX: center.x,
                    startY: center.y,
                    speed: 1.2 + (i % 3) * 0.2,
                    plantTimer: 200 + i * 60,
                    plantCooldown: 200 + i * 60,
                };
            });
            
            // Clear bombs and explosions
            bombs = [];
            explosions = [];
            frameCount = 0;
            
            // Update UI
            updateUI();
            
            // Start game loop
            gameLoop();
        };

        const nextLevel = () => {
            // Hide all modals first
            hideAllModals();
            
            currentLevel++;
            gameStatus = "playing";
            powerUpActive = false;
            
            // Generate new maze
            maze = generateLevelMaze(currentLevel);
            
            // Initialize collectibles
            const collectibles = initCollectibles(maze);
            dots = collectibles.dots;
            powerUps = collectibles.powerUps;
            
            // Reset Pac-Man
            pacman = {
                x: 1.5 * CELL_SIZE,
                y: 1.5 * CELL_SIZE,
                direction: { x: 0, y: 0 },
                nextDirection: { x: 0, y: 0 },
                speed: 2.5,
                mouthOpen: 0,
            };
            
            // Reset ghosts
            ghosts = ghostStarts.map((s, i) => {
                const center = cellCenter(s.r, s.c);
                return {
                    id: i,
                    x: center.x,
                    y: center.y,
                    color: ghostColors[i % ghostColors.length],
                    scared: false,
                    startX: center.x,
                    startY: center.y,
                    speed: 1.2 + (i % 3) * 0.2,
                    plantTimer: 200 + i * 60,
                    plantCooldown: 200 + i * 60,
                };
            });
            
            // Clear bombs and explosions
            bombs = [];
            explosions = [];
            
            // Update UI
            updateUI();
            
            // Start game loop
            gameLoop();
        };

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (["ArrowUp", "w"].includes(e.key)) pacman.nextDirection = { x: 0, y: -1 };
            if (["ArrowDown", "s"].includes(e.key)) pacman.nextDirection = { x: 0, y: 1 };
            if (["ArrowLeft", "a"].includes(e.key)) pacman.nextDirection = { x: -1, y: 0 };
            if (["ArrowRight", "d"].includes(e.key)) pacman.nextDirection = { x: 1, y: 0 };
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.getElementById('play-again-won').addEventListener('click', initGame);
        document.getElementById('play-again-lost').addEventListener('click', initGame);
        document.getElementById('next-level-button').addEventListener('click', nextLevel);

        // Start the game
        initGame();
    </script>
</body>
</html>
